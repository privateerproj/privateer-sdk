
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>command: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/privateerproj/privateer-sdk/command/base.go (78.3%)</option>
				
				<option value="file1">github.com/privateerproj/privateer-sdk/command/plugin.go (36.0%)</option>
				
				<option value="file2">github.com/privateerproj/privateer-sdk/config/config.go (93.9%)</option>
				
				<option value="file3">github.com/privateerproj/privateer-sdk/config/getters.go (87.5%)</option>
				
				<option value="file4">github.com/privateerproj/privateer-sdk/pluginkit/change.go (93.2%)</option>
				
				<option value="file5">github.com/privateerproj/privateer-sdk/pluginkit/errors.go (52.9%)</option>
				
				<option value="file6">github.com/privateerproj/privateer-sdk/pluginkit/evaluation_orchestrator.go (10.1%)</option>
				
				<option value="file7">github.com/privateerproj/privateer-sdk/pluginkit/evaluation_suite.go (92.9%)</option>
				
				<option value="file8">github.com/privateerproj/privateer-sdk/pluginkit/get_plugin_catalogs.go (88.2%)</option>
				
				<option value="file9">github.com/privateerproj/privateer-sdk/pluginkit/test_data.go (83.8%)</option>
				
				<option value="file10">github.com/privateerproj/privateer-sdk/utils/random.go (0.0%)</option>
				
				<option value="file11">github.com/privateerproj/privateer-sdk/utils/utils.go (51.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package command

// Wontfix: Logging in this file has unexpected behavior related to the WriteDirectory and loglevel values.

import (
        "log"
        "os"
        "path/filepath"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// SetBase sets the base flags for all commands
func SetBase(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.PersistentFlags().StringP("config", "c", defaultConfigPath(), "Configuration File, JSON or YAML")
        _ = viper.BindPFlag("config", cmd.PersistentFlags().Lookup("config"))

        cmd.PersistentFlags().StringP("write-directory", "w", "evaluation_results", "Directory to write evaluation results to")
        _ = viper.BindPFlag("write-directory", cmd.PersistentFlags().Lookup("write-directory"))

        cmd.PersistentFlags().StringP("loglevel", "l", "error", "Log level (trace, debug, info, warn, error, off)")
        _ = viper.BindPFlag("loglevel", cmd.PersistentFlags().Lookup("loglevel"))

        cmd.PersistentFlags().StringP("service", "s", "", "Named service to execute from the config")
        _ = viper.BindPFlag("service", cmd.PersistentFlags().Lookup("service"))

        cmd.PersistentFlags().StringP("test-suites", "t", "default", "Named set of test sets to execute from the plugin")
        _ = viper.BindPFlag("test-suites", cmd.PersistentFlags().Lookup("test-suites"))

        cmd.PersistentFlags().BoolP("silent", "", false, "Only show essential log information")
        _ = viper.BindPFlag("silent", cmd.PersistentFlags().Lookup("silent"))

        cmd.PersistentFlags().BoolP("write", "", true, "Keep all of the detailed result outputs in a file. Disabling does not disable log files")
        _ = viper.BindPFlag("write", cmd.PersistentFlags().Lookup("write"))

        cmd.PersistentFlags().BoolP("help", "h", false, "Give me a heading! Help for the specified command")
}</span>

func ReadConfig() <span class="cov0" title="0">{
        viper.SetConfigFile(viper.GetString("config"))
        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                log.Print("[ERROR] " + err.Error())
        }</span>
}

func defaultConfigPath() string <span class="cov8" title="1">{
        workDir, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return filepath.Join(workDir, "config.yml")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package command

import (
        "fmt"
        "os"
        "text/tabwriter"

        "github.com/privateerproj/privateer-sdk/pluginkit"
        "github.com/privateerproj/privateer-sdk/shared"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

type Plugin struct{}

var ActiveEvaluationOrchestrator *pluginkit.EvaluationOrchestrator

// Start will be called by Privateer via gRPC
func (p *Plugin) Start() error <span class="cov0" title="0">{
        return ActiveEvaluationOrchestrator.Mobilize()
}</span>

func NewPluginCommands(pluginName, buildVersion, buildGitCommitHash, buildTime string, orchestrator *pluginkit.EvaluationOrchestrator) *cobra.Command <span class="cov1" title="1">{

        ActiveEvaluationOrchestrator = orchestrator

        runCmd := runCommand(pluginName)

        runCmd.AddCommand(debugCommand())

        runCmd.AddCommand(
                versionCommand(buildVersion, buildGitCommitHash, buildTime))

        SetBase(runCmd)
        return runCmd
}</span>

func runCommand(pluginName string) *cobra.Command <span class="cov10" title="2">{
        return &amp;cobra.Command{
                Use:   pluginName,
                Short: fmt.Sprintf("Test suite for %s.", pluginName),
                PersistentPreRun: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ReadConfig()
                }</span>,
                Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                        // Serve plugin
                        plugin := &amp;Plugin{}
                        serveOpts := &amp;shared.ServeOpts{
                                Plugin: plugin,
                        }

                        shared.Serve(pluginName, serveOpts)
                }</span>,
        }
}

func debugCommand() *cobra.Command <span class="cov10" title="2">{
        return &amp;cobra.Command{
                Use:   "debug",
                Short: "Run the Plugin in debug mode",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        cmd.Print("Running in debug mode\n")
                        err := ActiveEvaluationOrchestrator.Mobilize()
                        if err != nil </span><span class="cov0" title="0">{
                                cmd.Println(err)
                        }</span>
                },
        }
}

func versionCommand(
        buildVersion, buildGitCommitHash, buildTime string) *cobra.Command <span class="cov10" title="2">{
        return &amp;cobra.Command{
                Use:   "version",
                Short: "Display version details.",
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        writer := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
                        if viper.GetBool("verbose") </span><span class="cov0" title="0">{
                                _, _ = fmt.Fprintf(writer, "Version:\t%s\n", buildVersion)
                                _, _ = fmt.Fprintf(writer, "Commit:\t%s\n", buildGitCommitHash)
                                _, _ = fmt.Fprintf(writer, "Build Time:\t%s\n", buildTime)
                                _ = writer.Flush()
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Println(buildVersion)
                        }</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "errors"
        "fmt"
        "io"
        "log"
        "os"
        "path"
        "path/filepath"
        "slices"
        "strings"
        "time"

        "github.com/hashicorp/go-hclog"
        "github.com/spf13/viper"
)

var allowedOutputTypes = []string{"json", "yaml", "sarif"}

type Config struct {
        ServiceName    string // Must be unique in the config file or logs will be overwritten
        LogLevel       string
        Logger         hclog.Logger
        Write          bool
        Output         string
        WriteDirectory string
        Invasive       bool
        Policy         Policy
        Vars           map[string]interface{}
        Error          error
}

type Policy struct {
        // TODO: We will want to replace this with a Gemara layer3 object now that those are ready
        ControlCatalogs []string
        Applicability   []string
}

func NewConfig(requiredVars []string) Config <span class="cov8" title="27">{
        var errString string

        serviceName := viper.GetString("service") // the currently running service; if empty, we're probably running from core

        write := viper.GetBool("write")                                         // defaults to true, but allow the user to disable file writing
        output := strings.ToLower(strings.TrimSpace(viper.GetString("output"))) // defaults to yaml, but can be set to json

        vars := viper.GetStringMap("vars")
        localVars := viper.GetStringMap(fmt.Sprintf("services.%s.vars", serviceName))
        for key, value := range localVars </span><span class="cov5" title="8">{
                // Overwrite or add local vars onto the global vars
                vars[key] = value
        }</span>

        <span class="cov8" title="27">topLoglevel := viper.GetString("loglevel")
        loglevel := viper.GetString(fmt.Sprintf("services.%s.loglevel", serviceName))
        if loglevel == "" &amp;&amp; topLoglevel != "" </span><span class="cov1" title="1">{
                loglevel = topLoglevel
        }</span> else<span class="cov8" title="26"> if loglevel == "" </span><span class="cov8" title="24">{
                loglevel = "Error"
        }</span>

        <span class="cov8" title="27">writeDir := viper.GetString("write-directory")
        if writeDir == "" </span><span class="cov8" title="26">{
                writeDir = defaultWritePath()
        }</span>

        <span class="cov8" title="27">topInvasive := viper.GetBool("invasive") // make sure we're actually using this to block changes
        invasive := viper.GetBool(fmt.Sprintf("services.%s.invasive", serviceName))
        if !invasive &amp;&amp; topInvasive </span><span class="cov1" title="1">{
                invasive = topInvasive
        }</span>

        <span class="cov8" title="27">topCatalogs := viper.GetStringSlice("policy.catalogs")
        catalogs := viper.GetStringSlice(fmt.Sprintf("services.%s.policy.catalogs", serviceName))
        if len(catalogs) == 0 </span><span class="cov2" title="2">{
                catalogs = topCatalogs
        }</span>

        <span class="cov8" title="27">topApplicability := viper.GetStringSlice("policy.applicability")
        applicability := viper.GetStringSlice(fmt.Sprintf("services.%s.policy.applicability", serviceName))
        if len(applicability) == 0 </span><span class="cov3" title="3">{
                applicability = topApplicability
        }</span>

        <span class="cov8" title="27">if serviceName != "" &amp;&amp; (len(applicability) == 0 || len(catalogs) == 0) </span><span class="cov2" title="2">{
                errString = fmt.Sprintf("invalid policy for service %s. applicability=%v catalogs=%v",
                        serviceName, len(applicability), len(catalogs))
        }</span>

        <span class="cov8" title="27">var missingVars []string
        for _, key := range requiredVars </span><span class="cov7" title="14">{
                if _, ok := vars[key]; !ok </span><span class="cov5" title="6">{
                        missingVars = append(missingVars, key)
                }</span>
        }
        <span class="cov8" title="27">if len(missingVars) &gt; 0 </span><span class="cov4" title="4">{
                errString = fmt.Sprintf("missing required variables: %v", missingVars)
        }</span>

        <span class="cov8" title="27">if output == "" </span><span class="cov8" title="24">{
                output = "yaml"
        }</span> else<span class="cov3" title="3"> if ok := slices.Contains(allowedOutputTypes, output); !ok </span><span class="cov1" title="1">{
                errString = "bad output type, allowed output types are json or yaml"
        }</span>

        <span class="cov8" title="27">var err error
        if errString != "" </span><span class="cov5" title="7">{
                err = errors.New(errString)
        }</span>

        <span class="cov8" title="27">config := Config{
                ServiceName:    serviceName,
                LogLevel:       loglevel,
                WriteDirectory: writeDir,
                Write:          write,
                Output:         output,
                Invasive:       invasive,
                Policy: Policy{
                        ControlCatalogs: catalogs,
                        Applicability:   applicability,
                },
                Vars:  vars,
                Error: err,
        }
        if serviceName == "" </span><span class="cov0" title="0">{
                serviceName = "overview"
        }</span>
        <span class="cov8" title="27">config.SetupLogging(serviceName, output == "json")
        printSanitizedVars(config.Logger, vars)
        config.Logger.Trace("Creating a new config instance for service",
                "serviceName", serviceName,
                "loglevel", loglevel,
                "write", write,
                "write-directory", writeDir,
                "invasive", invasive,
                "applicability", applicability,
                "control-catalogs", catalogs,
                "vars", vars,
                "output", output,
        )
        return config</span>
}

func printSanitizedVars(logger hclog.Logger, vars map[string]interface{}) <span class="cov8" title="27">{
        sanitizedVars := make(map[string]interface{})
        for key, value := range vars </span><span class="cov6" title="10">{
                switch key </span>{
                case "token", "auth", "password", "secret", "apikey", "api_key":<span class="cov0" title="0">
                        sanitizedVars[key] = "REDACTED"</span>
                default:<span class="cov6" title="10">
                        sanitizedVars[key] = value</span>
                }
        }
        <span class="cov8" title="27">logger.Trace("Using vars: %v", sanitizedVars)</span>
}

func defaultWritePath() string <span class="cov10" title="45">{
        home, err := os.UserHomeDir()
        datetime := time.Now().Local().Format(time.RFC3339)
        dirName := strings.ReplaceAll(datetime, ":", "")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov10" title="45">return filepath.Join(home, ".privateer", "logs", dirName)</span>
}

func (c *Config) SetupLogging(name string, jsonFormat bool) <span class="cov8" title="27">{
        var logFilePath string
        logFile := name + ".log"
        if name == "overview" </span><span class="cov0" title="0">{
                // if this is not a plugin, do not nest within a directory
                logFilePath = path.Join(c.WriteDirectory, logFile)
        }</span> else<span class="cov8" title="27"> {
                // otherwise, nest within a directory with the same name as the plugin
                logFilePath = path.Join(c.WriteDirectory, name, logFile)
        }</span>

        <span class="cov8" title="27">writer := io.Writer(os.Stdout)
        if c.Write </span><span class="cov1" title="1">{
                writer = c.setupLoggingFilesAndDirectories(logFilePath)
        }</span>

        <span class="cov8" title="27">logger := hclog.New(&amp;hclog.LoggerOptions{
                Level:      hclog.LevelFromString(c.LogLevel),
                JSONFormat: jsonFormat,
                Output:     writer,
        })
        log.SetOutput(logger.StandardWriter(&amp;hclog.StandardLoggerOptions{InferLevels: false, InferLevelsWithTimestamp: false}))
        c.Logger = logger</span>
}

func (c *Config) setupLoggingFilesAndDirectories(logFilePath string) io.Writer <span class="cov1" title="1">{
        // Create log file and directory if it doesn't exist
        if _, err := os.Stat(logFilePath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                // mkdir all directories from filepath
                _ = os.MkdirAll(path.Dir(logFilePath), os.ModePerm)
                _, _ = os.Create(logFilePath)
        }</span>

        <span class="cov1" title="1">logFileObj, err := os.OpenFile(logFilePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0640)

        if err != nil </span><span class="cov0" title="0">{
                log.Panic(err) // TODO: handle this error better
        }</span>

        <span class="cov1" title="1">writer := io.MultiWriter(logFileObj, os.Stdout)
        return writer</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
)

// GetVar retrieves the value associated with the given key from the Config's Vars map.
// It returns the value as an interface{} and a string representing the type of the value.
// Useful for debugging in the event that a value is not being retrieved as expected.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - interface{}: The value associated with the key.
//   - string: The type of the value associated with the key. If the key does not exist, it returns "missing".
func (c *Config) GetVar(key string) (interface{}, string) <span class="cov10" title="49">{
        val, ok := c.Vars[key]
        if !ok </span><span class="cov5" title="7">{
                return nil, "missing"
        }</span>
        <span class="cov9" title="42">return val, fmt.Sprintf("%T", val)</span>
}

// GetString retrieves the value associated with the given key from the Config object.
// If the value is not of type string, it returns an empty string.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - string: The value associated with the key, or an empty string if the value is not of type string.
func (c *Config) GetString(key string) string <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "string" </span><span class="cov5" title="6">{
                return ""
        }</span>
        <span class="cov1" title="1">return val.(string)</span>
}

// GetInt retrieves the value associated with the given key as an integer.
// If the value is not of type int, it returns 0.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - int: The value associated with the key, or 0 if the value is not of type int.
func (c *Config) GetInt(key string) int <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "int" </span><span class="cov5" title="6">{
                return 0
        }</span>
        <span class="cov1" title="1">return val.(int)</span>
}

// GetBool retrieves the value associated with the given key as a boolean.
// If the value is not of type boolean, it returns false.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - bool: The boolean value associated with the key, or false if the value is not a boolean.
func (c *Config) GetBool(key string) bool <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "bool" </span><span class="cov5" title="6">{
                return false
        }</span>
        <span class="cov1" title="1">return val.(bool)</span>
}

// GetMap retrieves a value from the configuration as a map[string]interface{}.
// It takes a key as a string and returns the corresponding value if it is of type map[string]interface{}.
// If the value is not of the expected type, it returns nil.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - map[string]interface{}: The value associated with the key if it is of the correct type
//   - nil: If the value is not of type map[string]interface{} or the key does not exist.
func (c *Config) GetMap(key string) map[string]interface{} <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "map[string]interface {}" </span><span class="cov5" title="6">{
                return nil
        }</span>
        <span class="cov1" title="1">return val.(map[string]interface{})</span>
}

// GetStringSlice retrieves the value associated with the given key as a slice of strings.
// If the value is not of type []string, it returns nil.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - []string: The value associated with the key as a slice of strings
//   - nil: If the value is not of type []string or the key does not exist.
func (c *Config) GetStringSlice(key string) []string <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "[]string" </span><span class="cov5" title="6">{
                return nil
        }</span>
        <span class="cov1" title="1">return val.([]string)</span>
}

// GetIntSlice retrieves the value associated with the given key as a slice of integers.
// If the value is not of type []int, it returns nil.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - []int: The value associated with the key as a slice of integers
//   - nil: If the value is not of type []int or the key does not exist.
func (c *Config) GetIntSlice(key string) []int <span class="cov5" title="7">{
        val, valType := c.GetVar(key)
        if valType != "[]int" </span><span class="cov5" title="6">{
                return nil
        }</span>
        <span class="cov1" title="1">return val.([]int)</span>
}

// GetBoolSlice retrieves a slice of boolean values from the configuration
// based on the provided key. If the key does not exist or the value is not
// of type []bool, it returns nil.
//
// Parameters:
//   - key: The key name in the config vars.
//
// Returns:
//   - []bool: A slice of boolean values if the key exists and the value is of type []bool.
//   - nil: If the key does not exist or the value is not of type []bool.
func (c *Config) GetBoolSlice(key string) []bool <span class="cov0" title="0">{
        val, valType := c.GetVar(key)
        if valType != "[]bool" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return val.([]bool)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package pluginkit

import (
        "fmt"
)

// Prepared function to apply the change
type ApplyFunc func(interface{}) (interface{}, error)

// Prepared function to revert the change after it has been applied
type RevertFunc func(interface{}) error

type ChangeManager struct {
        // Changes is a map of change names to Change objects, so that multiple changes can be tracked and reused.
        Changes map[string]*Change `yaml:"changes"`
        // Allowed must be set to true before any change can be applied.
        Allowed bool `yaml:"allowed,omitempty"`
        // CorruptedState is true if any change has failed to apply or revert, indicating that the system may be in a bad state.
        CorruptedState bool `yaml:"bad-state,omitempty"`
}

// Change is a struct that contains the data and functions associated with a single change to a target resource.
type Change struct {
        // TargetName is the name or ID of the resource or configuration that is to be changed
        TargetName string `yaml:"target-name"`
        // Description is a human-readable description of the change
        Description string `yaml:"description"`
        // applyFunc is the function that will be executed to make the change
        applyFunc ApplyFunc
        // revertFunc is the function that will be executed to undo the change
        revertFunc RevertFunc
        // TargetObject is an optional representation of the object that is being changed
        TargetObject interface{} `yaml:"target-object,omitempty"`
        // Applied is true if the change was successfully applied at least once
        Applied bool `yaml:"applied,omitempty"`
        // Reverted is true if the change was successfully reverted and not applied again
        Reverted bool `yaml:"reverted,omitempty"`
        // Error is used if any error occurred during the change
        Error error `yaml:"error,omitempty"`
        // CorruptedState is true if something went wrong during apply or revert, indicating that the system may be in a bad state
        CorruptedState bool `yaml:"bad-state,omitempty"`
}

// Allow marks the change as allowed to be applied.
func (cm *ChangeManager) Allow() <span class="cov4" title="3">{
        cm.Allowed = true
}</span>

func (cm *ChangeManager) AddChange(changeName string, change Change) <span class="cov1" title="1">{
        if cm.Changes == nil </span><span class="cov1" title="1">{
                cm.Changes = make(map[string]*Change)
        }</span>
        <span class="cov1" title="1">cm.Changes[changeName] = &amp;change</span>
}

func (c *Change) AddFunctions(applyFunc ApplyFunc, revertFunc RevertFunc) <span class="cov3" title="2">{
        c.applyFunc = applyFunc
        c.revertFunc = revertFunc
}</span>

// Apply the prepared function for the change. It will not apply the change if it is not allowed, or if it has already been applied and not reverted.
func (cm *ChangeManager) Apply(changeName string, targetName string, changeInput any) (success bool, target any) <span class="cov4" title="3">{
        if !cm.Allowed </span><span class="cov1" title="1">{
                return false, nil
        }</span>
        <span class="cov3" title="2">change, exists := cm.Changes[changeName]
        if !exists </span><span class="cov1" title="1">{
                return false, nil
        }</span>
        <span class="cov1" title="1">success, target = change.apply(targetName, changeInput)
        if change.CorruptedState </span><span class="cov0" title="0">{
                cm.CorruptedState = true
        }</span>
        <span class="cov1" title="1">return success, target</span>
}

func (cm *ChangeManager) Revert(changeName string) <span class="cov3" title="2">{
        change, exists := cm.Changes[changeName]
        if !exists </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov1" title="1">change.revert(change.TargetObject)
        if change.CorruptedState </span><span class="cov0" title="0">{
                cm.CorruptedState = true
        }</span>
}

func (cm *ChangeManager) RevertAll() <span class="cov5" title="4">{
        for _, change := range cm.Changes </span><span class="cov4" title="3">{
                change.revert(change.TargetObject)
                if change.CorruptedState </span><span class="cov1" title="1">{
                        cm.CorruptedState = true
                }</span>
        }
}

// Apply the prepared function for the change. It will not apply the change if it has already been applied and not reverted.
// It will also not apply the change if it is not allowed.
func (c *Change) apply(targetName string, changeInput any) (success bool, target any) <span class="cov6" title="5">{
        err := c.precheck()
        // Return error if precheck fails
        if err != nil </span><span class="cov1" title="1">{
                c.Error = err
                return false, c.TargetObject
        }</span>

        // Do nothing if the change has already been applied and not reverted
        <span class="cov5" title="4">if c.Applied &amp;&amp; !c.Reverted </span><span class="cov1" title="1">{
                return true, c.TargetObject
        }</span>

        <span class="cov4" title="3">c.TargetName = targetName
        c.TargetObject, err = c.applyFunc(changeInput)
        if err != nil </span><span class="cov1" title="1">{
                c.CorruptedState = true
                c.Error = err
                return false, c.TargetObject
        }</span>
        <span class="cov3" title="2">c.Applied = true
        c.Reverted = false
        return true, c.TargetObject</span>
}

// Revert the change by executing the revert function. It does nothing if it has not been applied.
func (c *Change) revert(data interface{}) <span class="cov7" title="7">{
        if !c.Applied </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov6" title="6">err := c.precheck()
        if err != nil </span><span class="cov0" title="0">{
                c.Error = err
                return
        }</span>
        <span class="cov6" title="6">err = c.revertFunc(data)
        if err != nil </span><span class="cov3" title="2">{
                c.Error = err
                c.CorruptedState = true
                return
        }</span>
        <span class="cov5" title="4">c.Reverted = true</span>
}

// precheck verifies that the applyFunc and revertFunc are defined for the change.
// It returns an error if the change is not valid.
func (c *Change) precheck() error <span class="cov10" title="17">{
        if c.applyFunc == nil || c.revertFunc == nil </span><span class="cov4" title="3">{
                return fmt.Errorf("applyFunc and revertFunc must be defined for a change, but got applyFunc: %v, revertFunc: %v",
                        c.applyFunc != nil, c.revertFunc != nil)
        }</span>
        <span class="cov9" title="14">if c.TargetName == "" || c.Description == "" </span><span class="cov3" title="2">{
                return fmt.Errorf("change must have a TargetName and Description defined, but got TargetName: %v, Description: %v",
                        c.TargetName, c.Description)
        }</span>
        <span class="cov8" title="12">if c.Error != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("change has a previous error and can no longer be applied: %s", c.Error.Error())
        }</span>
        <span class="cov8" title="11">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// errors.go contains error definitions to streamline testing and log management
package pluginkit

import (
        "fmt"
)

// Errors with no parameters
var (
        CORRUPTION_FOUND = func(mod string) error <span class="cov0" title="0">{
                return errMod("target state may be corrupted! Halting to prevent futher damage. See logs for more information", mod)
        }</span>
        NO_EVALUATION_SUITES = func(mod string) error <span class="cov0" title="0">{
                return errMod("no control evaluations provided by the plugin", mod)
        }</span>
        EVAL_NAME_MISSING = func(mod string) error <span class="cov0" title="0">{
                return errMod("evaluationSuite name must not be empty", mod)
        }</span>
        CONFIG_NOT_INITIALIZED = func(mod string) error <span class="cov1" title="1">{
                return errMod("configuration not initialized", mod)
        }</span>
        NO_ASSESSMENT_STEPS_PROVIDED = func(mod string) error <span class="cov9" title="90">{
                return errMod("assessment steps not provided", mod)
        }</span>
        NO_ASSESSMENT_REQS_PROVIDED = func(mod string) error <span class="cov3" title="4">{
                return errMod("assessment requirements not provided", mod)
        }</span>
        EVAL_SUITE_CRASHED = func(mod string) error <span class="cov2" title="2">{
                return errMod("evaluation suite crashed", mod)
        }</span>
)

// Errors with parameters required
var (
        EVALUATION_ORCHESTRATOR_NAMES_NOT_SET = func(serviceName, pluginName string, mod string) error <span class="cov0" title="0">{
                return errMod(fmt.Errorf("expected service and plugin names to be set. ServiceName='%s' PluginName='%s'", serviceName, pluginName), mod)
        }</span>
        WRITE_FAILED = func(name, err string, mod string) error <span class="cov0" title="0">{
                return errMod(fmt.Errorf("failed to write results for evaluation suite. name: %s, error: %s", name, err), mod)
        }</span>
        BAD_LOADER = func(pluginName string, err error, mod string) error <span class="cov0" title="0">{
                return errMod(fmt.Errorf("failed to load payload for %s: %s", pluginName, err), mod)
        }</span>
        BAD_CATALOG = func(pluginName string, errMsg string, mod string) error <span class="cov1" title="1">{
                return errMod(fmt.Errorf("malformed data in catalog for %s: %s", pluginName, errMsg), mod)
        }</span>
        BAD_EVAL_LOG = func(err error, mod string) error <span class="cov3" title="4">{
                return errMod(fmt.Errorf("failed to setup evaluation log: %w", err), mod)
        }</span>
        BAD_ASSESSMENT_REQS = func(err error, mod string) error <span class="cov2" title="2">{
                return errMod(fmt.Errorf("failed to load assessment requirements from catalog: %w", err), mod)
        }</span>
        BAD_CONFIG = func(err error, mod string) error <span class="cov0" title="0">{
                return errMod(fmt.Errorf("failed to setup config: %w", err), mod)
        }</span>
)

func errMod(err any, mod string) error <span class="cov10" title="104">{
        if err != nil </span><span class="cov10" title="104">{
                return fmt.Errorf("%+v+%s", err, mod)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package pluginkit

import (
        "embed"
        "encoding/json"
        "errors"
        "fmt"
        "os"
        "path"
        "strings"

        "github.com/goccy/go-yaml"
        "github.com/gemaraproj/go-gemara"
        "github.com/gemaraproj/go-gemara"
        "github.com/privateerproj/privateer-sdk/config"
)

// The evaluation orchestrator gets the plugin in position to execute the specified evaluation suites
type EvaluationOrchestrator struct {
        ServiceName       string             `yaml:"service-name"`
        PluginName        string             `yaml:"plugin-name"`
        PluginUri         string             `yaml:"plugin-uri"`
        PluginVersion     string             `yaml:"plugin-version"`
        Payload           any                `yaml:"payload,omitempty"`
        Evaluation_Suites []*EvaluationSuite `yaml:"evaluation-suites"` // EvaluationSuite is a map of evaluations to their catalog names

        possibleSuites    []*EvaluationSuite
        possibleControls  map[string][]*gemara.Control
        referenceCatalogs map[string]*gemara.ControlCatalog
        requiredVars      []string
        config            *config.Config
        loader            DataLoader
}

type DataLoader func(*config.Config) (any, error)

func (v *EvaluationOrchestrator) AddLoader(loader DataLoader) <span class="cov6" title="2">{
        v.loader = loader
}</span>

func (v *EvaluationOrchestrator) AddRequiredVars(vars []string) <span class="cov6" title="2">{
        v.requiredVars = vars
}</span>

func (v *EvaluationOrchestrator) AddReferenceCatalogs(dataDir string, files embed.FS) error <span class="cov10" title="3">{
        if v.referenceCatalogs == nil </span><span class="cov10" title="3">{
                v.referenceCatalogs = make(map[string]*gemara.ControlCatalog)
        }</span>
        <span class="cov10" title="3">if dataDir == "" </span><span class="cov1" title="1">{
                return errors.New("data directory name cannot be empty")
        }</span>
        <span class="cov6" title="2">catalogs, err := getPluginCatalogs(dataDir, files)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov1" title="1">for _, catalog := range catalogs </span><span class="cov1" title="1">{
                if catalog.Metadata.Id == "" </span><span class="cov1" title="1">{
                        return errors.New("catalog id cannot be empty")
                }</span>
                <span class="cov0" title="0">if _, exists := v.referenceCatalogs[catalog.Metadata.Id]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate catalog id found: %s", catalog.Metadata.Id)
                }</span>
                <span class="cov0" title="0">v.referenceCatalogs[catalog.Metadata.Id] = catalog
                v.addPossibleControls(catalog)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *EvaluationOrchestrator) addPossibleControls(catalog *gemara.ControlCatalog) <span class="cov0" title="0">{
        if v.possibleControls == nil </span><span class="cov0" title="0">{
                v.possibleControls = make(map[string][]*gemara.Control)
        }</span>
        <span class="cov0" title="0">for _, family := range catalog.Families </span><span class="cov0" title="0">{
                for i := range family.Controls </span><span class="cov0" title="0">{
                        control := &amp;family.Controls[i]
                        if _, exists := v.possibleControls[control.Id]; !exists </span><span class="cov0" title="0">{
                                v.possibleControls[control.Id] = []*gemara.Control{control}
                        }</span> else<span class="cov0" title="0"> {
                                v.possibleControls[control.Id] = append(v.possibleControls[control.Id], control)
                        }</span>
                }
        }
}

func (v *EvaluationOrchestrator) AddEvaluationSuite(catalogId string, loader DataLoader, steps map[string][]gemara.AssessmentStep) error <span class="cov1" title="1">{
        if catalogId == "" </span><span class="cov0" title="0">{
                return BAD_CATALOG(v.PluginName, "suite catalog id cannot be empty", "aos10")
        }</span>
        <span class="cov1" title="1">if catalog, ok := v.referenceCatalogs[catalogId]; ok </span><span class="cov0" title="0">{
                if len(catalog.) == 0 </span><span class="cov0" title="0">{
                        return BAD_CATALOG(v.PluginName, "no control families provided", "aos20")
                }</span>
                <span class="cov0" title="0">if catalog.Metadata.Id == "" </span><span class="cov0" title="0">{
                        return BAD_CATALOG(v.PluginName, "no id found in catalog metadata", "aos30")
                }</span>
                <span class="cov0" title="0">v.addEvaluationSuite(catalog, loader, steps)
                return nil</span>
        }
        <span class="cov1" title="1">return BAD_CATALOG(v.PluginName, fmt.Sprintf("no reference catalog found with id '%s'", catalogId), "aos40")</span>
}

func (v *EvaluationOrchestrator) addEvaluationSuite(catalog *gemara.ControlCatalog, loader DataLoader, steps map[string][]gemara.AssessmentStep) <span class="cov0" title="0">{
        importedControlFamilies := getImportedControlFamilies(catalog, v.referenceCatalogs)
        catalog.Families = append(catalog.Families, importedControlFamilies...)

        suite := EvaluationSuite{
                CatalogId: catalog.Metadata.Id,
                catalog:   catalog,
                steps:     steps,
                config:    v.config,
        }

        if loader != nil </span><span class="cov0" title="0">{
                suite.loader = loader
        }</span> else<span class="cov0" title="0"> {
                suite.loader = v.loader
        }</span>
        <span class="cov0" title="0">v.possibleSuites = append(v.possibleSuites, &amp;suite)</span>
}

// getImportedControlFamilies creates a new control family entry for each imported catalog
// and only includes controls from the imported catalog that are listed in the imports of the primary catalog
func getImportedControlFamilies(catalog *gemara.ControlCatalog, referenceCatalogs map[string]*gemara.ControlCatalog) (importedFamilies []gemara.ControlFamily) <span class="cov0" title="0">{
        if len(catalog.ImportedControls) == 0 </span><span class="cov0" title="0">{
                return importedFamilies
        }</span>
        <span class="cov0" title="0">for _, importEntry := range catalog.ImportedControls </span><span class="cov0" title="0">{
                if refCatalog, ok := referenceCatalogs[importEntry.ReferenceId]; ok </span><span class="cov0" title="0">{
                        var importedControls []gemara.Control
                        for _, mapping := range importEntry.Entries </span><span class="cov0" title="0">{
                                if controls, exists := referenceCatalogs[importEntry.ReferenceId]; exists </span><span class="cov0" title="0">{
                                        for _, family := range controls.Families </span><span class="cov0" title="0">{
                                                for i := range family.Controls </span><span class="cov0" title="0">{
                                                        control := &amp;family.Controls[i]
                                                        if control.Id == mapping.ReferenceId </span><span class="cov0" title="0">{
                                                                importedControls = append(importedControls, *control)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">if len(importedControls) &gt; 0 </span><span class="cov0" title="0">{
                                family := gemara.ControlFamily{
                                        Id:          fmt.Sprintf("imported-%s", refCatalog.Metadata.Id),
                                        Title:       fmt.Sprintf("Imported Controls from %s", refCatalog.Title),
                                        Description: fmt.Sprintf("This control family contains controls imported from the %s catalog.", refCatalog.Title),
                                        Controls:    importedControls,
                                }
                                importedFamilies = append(importedFamilies, family)
                        }</span>
                }
        }
        <span class="cov0" title="0">return importedFamilies</span>
}

func (v *EvaluationOrchestrator) Mobilize() error <span class="cov0" title="0">{
        v.setupConfig()
        if v.config.Error != nil </span><span class="cov0" title="0">{
                return BAD_CONFIG(v.config.Error, "mob10")
        }</span>

        <span class="cov0" title="0">if len(v.config.Policy.ControlCatalogs) == 0 </span><span class="cov0" title="0">{
                return BAD_CONFIG(v.config.Error, "mob20")
        }</span>

        <span class="cov0" title="0">err := v.loadPayload()
        if err != nil </span><span class="cov0" title="0">{
                return BAD_LOADER(v.PluginName, err, "mob30")
        }</span>

        <span class="cov0" title="0">v.ServiceName = v.config.ServiceName

        if v.PluginName == "" || v.ServiceName == "" </span><span class="cov0" title="0">{
                return EVALUATION_ORCHESTRATOR_NAMES_NOT_SET(v.ServiceName, v.PluginName, "mob40")
        }</span>

        <span class="cov0" title="0">v.config.Logger.Trace("Mobilization beginning")
        if len(v.possibleSuites) == 0 </span><span class="cov0" title="0">{
                return NO_EVALUATION_SUITES("mob50")
        }</span>

        <span class="cov0" title="0">for _, catalog := range v.config.Policy.ControlCatalogs </span><span class="cov0" title="0">{
                for _, suite := range v.possibleSuites </span><span class="cov0" title="0">{
                        if suite.CatalogId == catalog </span><span class="cov0" title="0">{
                                err := suite.Evaluate(v.ServiceName)
                                if err != nil </span><span class="cov0" title="0">{
                                        v.config.Logger.Error(err.Error())
                                }</span>
                                <span class="cov0" title="0">v.Evaluation_Suites = append(v.Evaluation_Suites, suite)</span>
                        }
                }
        }
        <span class="cov0" title="0">v.config.Logger.Trace("Mobilization complete")

        if !v.config.Write </span><span class="cov0" title="0">{
                return nil // Do not write results if the user has blocked it
        }</span>
        <span class="cov0" title="0">return v.WriteResults()</span>
}

func (v *EvaluationOrchestrator) WriteResults() error <span class="cov0" title="0">{

        var err error
        var result []byte
        switch v.config.Output </span>{
        case "json":<span class="cov0" title="0">
                result, err = json.Marshal(v)
                err = errMod(err, "wr10")</span>
        case "yaml":<span class="cov0" title="0">
                result, err = yaml.Marshal(v)
                err = errMod(err, "wr20")</span>
        case "sarif":<span class="cov0" title="0">
                for _, suite := range v.Evaluation_Suites </span><span class="cov0" title="0">{
                        sarifBytes, err := suite.EvaluationLog.ToSARIF()
                        if err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">result = append(result, sarifBytes...)</span>
                }
        default:<span class="cov0" title="0">
                err = fmt.Errorf("output type '%s' is not supported. Supported types are 'json' and 'yaml'", v.config.Output)
                err = errMod(err, "wr30")</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return WRITE_FAILED(v.PluginName, err.Error(), "wr40")
        }</span>
        <span class="cov0" title="0">err = v.writeResultsToFile(v.ServiceName, result, v.config.Output)
        if err != nil </span><span class="cov0" title="0">{
                return WRITE_FAILED(v.ServiceName, err.Error(), "wr60")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (v *EvaluationOrchestrator) writeResultsToFile(serviceName string, result []byte, extension string) error <span class="cov0" title="0">{
        if !strings.Contains(extension, ".") </span><span class="cov0" title="0">{
                extension = fmt.Sprintf(".%s", extension)
        }</span>
        <span class="cov0" title="0">dir := path.Join(v.config.WriteDirectory, serviceName)
        filename := fmt.Sprintf("%s%s", v.ServiceName, extension)
        filepath := path.Join(dir, filename)

        v.config.Logger.Trace("Writing results", "filepath", filepath)

        // Create log file and directory if it doesn't exist
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.MkdirAll(dir, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        v.config.Logger.Error("Error creating directory", "directory", dir)
                        return err
                }</span>
                <span class="cov0" title="0">v.config.Logger.Warn("write directory for this plugin created for results, but should have been created when initializing logs", "directory", dir)</span>
        }

        <span class="cov0" title="0">_, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                v.config.Logger.Error("Error creating file", "filepath", filepath)
                return err
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(filepath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0640)
        if err != nil </span><span class="cov0" title="0">{
                v.config.Logger.Error("Error opening file", "filepath", filepath)
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = file.Close()
        }</span>()

        <span class="cov0" title="0">_, err = file.Write(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetPayload allows the user to pass data to be referenced in assessments
func (v *EvaluationOrchestrator) loadPayload() (err error) <span class="cov0" title="0">{
        payload := new(interface{})
        if v.loader != nil </span><span class="cov0" title="0">{
                data, err := v.loader(v.config)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">payload = &amp;data</span>
        }
        <span class="cov0" title="0">v.Payload = payload
        for _, suite := range v.possibleSuites </span><span class="cov0" title="0">{
                if suite.loader != nil </span><span class="cov0" title="0">{
                        data, err := suite.loader(v.config)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">suite.payload = data</span>
                } else<span class="cov0" title="0"> {
                        suite.payload = v.Payload
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *EvaluationOrchestrator) setupConfig() <span class="cov0" title="0">{
        if v.config == nil </span><span class="cov0" title="0">{
                c := config.NewConfig(v.requiredVars)
                v.config = &amp;c

                // Update all existing suites to point to the new config
                for _, suite := range v.possibleSuites </span><span class="cov0" title="0">{
                        suite.config = v.config
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package pluginkit

import (
        "fmt"
        "time"

        "github.com/gemaraproj/go-gemara"
        "github.com/gemaraproj/go-gemara"
        "github.com/privateerproj/privateer-sdk/config"
)

type TestSet func() (result gemara.ControlEvaluation)

// EvaluationSuite is a struct that contains the results of all EvaluationLog executions
// Exported fields will be used in the final YAML or JSON output documents
type EvaluationSuite struct {
        Name   string        // Name is the name of the suite
        Result gemara.Result // Result is Passed if all evaluations in the suite passed

        CatalogId string `yaml:"catalog-id"` // CatalogId associates this suite with a catalog
        StartTime string `yaml:"start-time"` // StartTime is the time the plugin started
        EndTime   string `yaml:"end-time"`   // EndTime is the time the plugin ended

        CorruptedState bool `yaml:"corrupted-state"` // CorruptedState is true if any testSet failed to revert at the end of the evaluation

        EvaluationLog gemara.EvaluationLog `yaml:"control-evaluations"` // EvaluationLog is a slice of evaluations to be executed

        config *config.Config // config is the global configuration

        payload       interface{}                        // payload is the data to be evaluated
        loader        DataLoader                         // loader is the function to load the payload
        changeManager *ChangeManager                     // changes is a list of changes made during the evaluation
        catalog       *gemara.ControlCatalog                    // The Catalog this evaluation suite references
        steps         map[string][]gemara.AssessmentStep // steps is a map of control IDs to their assessment steps

        evalSuccesses int // successes is the number of successful evaluations
        evalFailures  int // failures is the number of failed evaluations
        evalWarnings  int // warnings is the number of evaluations that need review
}

// AddChangeManager sets up the change manager for the evaluation suite
func (e *EvaluationSuite) AddChangeManager(cm *ChangeManager) <span class="cov3" title="5">{
        if e.config.Invasive &amp;&amp; cm != nil </span><span class="cov2" title="2">{
                e.changeManager = cm
                e.changeManager.Allow()
        }</span>
}

// Execute is used to execute a list of EvaluationLog provided by a Plugin and customized by user config
// Name is an arbitrary string that will be used to identify the EvaluationSuite
func (e *EvaluationSuite) Evaluate(serviceName string) error <span class="cov4" title="12">{
        if e.config == nil </span><span class="cov1" title="1">{
                return CONFIG_NOT_INITIALIZED("ev10")
        }</span>

        <span class="cov4" title="11">requirements, err := e.GetAssessmentRequirements()
        if err != nil </span><span class="cov2" title="2">{
                return BAD_ASSESSMENT_REQS(err, "ev20")
        }</span>

        <span class="cov4" title="9">evalLog, err := e.setupEvalLog(e.steps)
        if err != nil </span><span class="cov3" title="4">{
                return BAD_EVAL_LOG(err, "ev30")
        }</span>

        <span class="cov3" title="5">if len(evalLog.Evaluations) == 0 </span><span class="cov0" title="0">{
                return EVAL_SUITE_CRASHED("ev40")
        }</span>

        <span class="cov3" title="5">e.Name = fmt.Sprintf("%s_%s", serviceName, e.CatalogId)
        e.EvaluationLog = evalLog
        e.StartTime = time.Now().String()

        e.config.Logger.Trace("Starting evaluation", "name", e.Name, "time", e.StartTime)

        for _, evaluation := range e.EvaluationLog.Evaluations </span><span class="cov7" title="65">{
                evaluation.Evaluate(e.payload, e.config.Policy.Applicability)

                // Make sure the evaluation result is updated based on the complete assessment results
                e.Result = gemara.UpdateAggregateResult(e.Result, evaluation.Result)

                // Log each assessment result as a separate line
                for _, assessment := range evaluation.AssessmentLogs </span><span class="cov8" title="205">{
                        message := fmt.Sprintf("%s: %s", assessment.Requirement.EntryId, assessment.Message)
                        // switch case the code below
                        switch assessment.Result </span>{
                        case gemara.Passed:<span class="cov7" title="70">
                                e.config.Logger.Info(message)</span>
                        case gemara.NeedsReview:<span class="cov6" title="36">
                                e.config.Logger.Warn(message)</span>
                        case gemara.Failed:<span class="cov1" title="1">
                                e.config.Logger.Error(message)</span>
                        case gemara.Unknown:<span class="cov7" title="80">
                                e.config.Logger.Error(message)</span>
                        }

                        <span class="cov8" title="205">if len(requirements) &gt; 0 &amp;&amp; requirements[assessment.Requirement.EntryId] != nil </span><span class="cov8" title="205">{
                                assessment.Recommendation = requirements[assessment.Requirement.EntryId].Recommendation
                        }</span>
                }

                <span class="cov7" title="65">if evaluation.Result == gemara.Passed </span><span class="cov5" title="25">{
                        e.evalSuccesses += 1
                }</span> else<span class="cov6" title="40"> if evaluation.Result == gemara.Failed </span><span class="cov5" title="27">{
                        e.evalFailures += 1
                }</span> else<span class="cov4" title="13"> if evaluation.Result != gemara.NotRun </span><span class="cov4" title="13">{
                        e.evalWarnings += 1
                }</span>
                <span class="cov7" title="65">if e.changeManager != nil &amp;&amp; e.changeManager.CorruptedState </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov3" title="5">output := fmt.Sprintf("&gt; %s: %v Passed, %v Warnings, %v Failed, %v Possible", e.Name, e.evalSuccesses, e.evalWarnings, e.evalFailures, len(evalLog.Evaluations))

        e.EndTime = time.Now().String()

        if e.changeManager != nil </span><span class="cov1" title="1">{
                e.changeManager.RevertAll()
                if e.CorruptedState </span><span class="cov0" title="0">{
                        return CORRUPTION_FOUND("ev40")
                }</span>
        }

        <span class="cov3" title="5">switch e.Result </span>{
        case gemara.Passed:<span class="cov1" title="1">
                e.config.Logger.Info(output)</span>
        case gemara.NotRun:<span class="cov0" title="0">
                e.config.Logger.Trace(output)</span>
        default:<span class="cov3" title="4">
                e.config.Logger.Error(output)</span>
        }
        <span class="cov3" title="5">return nil</span>
}

func (e *EvaluationSuite) GetAssessmentRequirements() (map[string]*gemara.AssessmentRequirement, error) <span class="cov4" title="14">{
        requirements := make(map[string]*gemara.AssessmentRequirement)
        for _, family := range e.catalog.Families </span><span class="cov6" title="32">{
                for _, control := range family.Controls </span><span class="cov8" title="132">{
                        for _, requirement := range control.AssessmentRequirements </span><span class="cov10" title="410">{
                                requirements[requirement.Id] = &amp;requirement
                        }</span>
                }
        }

        <span class="cov4" title="14">if len(requirements) == 0 </span><span class="cov3" title="4">{
                return nil, NO_ASSESSMENT_REQS_PROVIDED("ev50")
        }</span>

        <span class="cov4" title="10">return requirements, nil</span>
}

func (e *EvaluationSuite) setupEvalLog(steps map[string][]gemara.AssessmentStep) (evalLog gemara.EvaluationLog, err error) <span class="cov4" title="14">{
        if len(steps) == 0 </span><span class="cov3" title="6">{
                return evalLog, NO_ASSESSMENT_STEPS_PROVIDED("sel10")
        }</span>

        // crash if reaching the end without a requirement
        // use errMod to add level of detail
        <span class="cov4" title="8">var controlsFound bool
        var reqsFound bool

        if len(e.catalog.Families) == 0 </span><span class="cov1" title="1">{
                return evalLog, EVAL_SUITE_CRASHED("sel20")
        }</span>

        <span class="cov3" title="7">for _, family := range e.catalog.Families </span><span class="cov5" title="19">{
                if len(family.Controls) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov5" title="19">controlsFound = true
                for _, control := range family.Controls </span><span class="cov7" title="79">{
                        if len(control.AssessmentRequirements) == 0 </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov7" title="78">reqsFound = true

                        // Create ControlEvaluation first
                        evaluation := &amp;gemara.ControlEvaluation{
                                Name: control.Title,
                                Control: gemara.Mapping{
                                        ReferenceId: e.CatalogId,
                                        EntryId:     control.Id,
                                },
                        }

                        for _, requirement := range control.AssessmentRequirements </span><span class="cov9" title="246">{
                                // Use AddAssessment instead of manual struct creation
                                assessment := evaluation.AddAssessment(
                                        requirement.Id,            // requirementId
                                        control.Objective,         // description
                                        requirement.Applicability, // applicability
                                        steps[requirement.Id],     // steps
                                )

                                // Handle case where no steps were found
                                if _, ok := steps[requirement.Id]; !ok </span><span class="cov8" title="120">{
                                        assessment.Result = gemara.Unknown
                                        if e.config != nil </span><span class="cov7" title="80">{
                                                msg := fmt.Sprintf("requirement: %s, control %s+sel30", requirement.Id, control.Id)
                                                err := NO_ASSESSMENT_STEPS_PROVIDED(msg)
                                                e.config.Logger.Debug(err.Error())
                                        }</span>
                                }
                        }
                        <span class="cov7" title="78">evalLog.Evaluations = append(evalLog.Evaluations, evaluation)</span>
                }
        }

        <span class="cov3" title="7">if !controlsFound </span><span class="cov0" title="0">{
                return evalLog, EVAL_SUITE_CRASHED("sel40")
        }</span>
        <span class="cov3" title="7">if !reqsFound </span><span class="cov1" title="1">{
                return evalLog, EVAL_SUITE_CRASHED("sel50")
        }</span>

        <span class="cov3" title="6">return evalLog, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package pluginkit

import (
        "embed"
        "fmt"
        "path"

        "github.com/gemaraproj/go-gemara"
        "gopkg.in/yaml.v3"
)

// TODO: When loading the catalogs, queue them all up
// expect one catalog per file, and give each one its own gemara.ControlCatalog
// Then we just need some parent object that contains map of catalogs by Id
// and figure out where we need to pass that around

// GetPluginCatalog reads all YAML catalog files in the data directory and returns the complete catalog data
// This is necessary when packaging the catalog files into a binary, which is not supported by the Gemara loader
// If a catalog imports another, both should be in the same directory
func getPluginCatalogs(dataDir string, files embed.FS) (catalogs []*gemara.ControlCatalog, err error) <span class="cov8" title="6">{
        dir, err := files.ReadDir(dataDir)
        // Check if files are in the right place
        if err != nil || len(dir) == 0 </span><span class="cov5" title="3">{
                return nil, fmt.Errorf("no contents found in directory: %s", dataDir)
        }</span>

        // Process each YAML file
        <span class="cov5" title="3">for _, file := range dir </span><span class="cov8" title="6">{
                filePath := path.Join(dataDir, file.Name())
                catalog, err := readYAMLFile(filePath, files)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="6">catalogs = append(catalogs, catalog)</span>
        }

        <span class="cov5" title="3">return catalogs, nil</span> // just returns the last catalog for now
}

// ReadYAMLFile reads a single YAML file and returns the control family data
func readYAMLFile(filePath string, files embed.FS) (*gemara.ControlCatalog, error) <span class="cov10" title="9">{
        data, err := files.ReadFile(filePath)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov9" title="8">var catalog gemara.ControlCatalog
        if err := yaml.Unmarshal(data, &amp;catalog); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal YAML: %w", err)
        }</span>

        <span class="cov9" title="8">return &amp;catalog, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package pluginkit

import (
        "fmt"
        "os"

        "github.com/gemaraproj/go-gemara"
        "github.com/gemaraproj/go-gemara"
        "github.com/spf13/viper"

        "github.com/privateerproj/privateer-sdk/config"
)

type testingData struct {
        testName               string
        evals                  []*gemara.ControlEvaluation // Keep for backward compatibility with other tests
        steps                  map[string][]gemara.AssessmentStep
        expectedEvalSuiteError error
        expectedResult         gemara.Result
}

var testCatalog = &amp;gemara.ControlCatalog{
        ControlFamilies: []gemara.ControlFamily{},
}

func getTestCatalog() (*gemara.ControlCatalog, error) <span class="cov6" title="17">{
        if len(testCatalog.Families) &gt; 0 </span><span class="cov0" title="0">{
                return testCatalog, nil
        }</span>
        <span class="cov6" title="17">catalog := &amp;gemara.ControlCatalog{}
        pwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get working directory when retrieving catalog: %w", err)
        }</span>
        <span class="cov6" title="17">file1 := fmt.Sprintf("file://%s/catalog-test-data/metadata.yaml", pwd)
        file2 := fmt.Sprintf("file://%s/catalog-test-data/controls.yaml", pwd)
        err = catalog.LoadFiles([]string{file1, file2})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="17">return catalog, nil</span>
}

// getEmptyTestCatalog returns an empty catalog for testing error conditions
func getEmptyTestCatalog() *gemara.ControlCatalog <span class="cov3" title="3">{
        return &amp;gemara.ControlCatalog{
                ControlFamilies: []gemara.ControlFamily{},
        }
}</span>

// getTestCatalogWithNoRequirements returns a catalog with controls but no assessment requirements
func getTestCatalogWithNoRequirements() *gemara.ControlCatalog <span class="cov3" title="3">{
        return &amp;gemara.ControlCatalog{
                ControlFamilies: []gemara.ControlFamily{
                        {
                                Id: "test-family",
                                Controls: []gemara.Control{
                                        {
                                                Id:                     "test-control",
                                                Title:                  "Test Control",
                                                Objective:              "Test objective",
                                                AssessmentRequirements: []gemara.AssessmentRequirement{}, // Empty requirements
                                        },
                                },
                        },
                },
        }
}</span>

func passingEvaluation() (evaluation *gemara.ControlEvaluation) <span class="cov4" title="6">{
        evaluation = &amp;gemara.ControlEvaluation{
                Control: gemara.Mapping{
                        EntryId: "good-evaluation",
                },
        }

        evaluation.AddAssessment(
                "assessment-good",
                "this assessment should work fine",
                requestedApplicability,
                []gemara.AssessmentStep{
                        step_Pass,
                },
        )
        return
}</span>

func failingEvaluation() (evaluation *gemara.ControlEvaluation) <span class="cov2" title="2">{
        evaluation = &amp;gemara.ControlEvaluation{
                Control: gemara.Mapping{
                        EntryId: "bad-evaluation",
                },
        }

        evaluation.AddAssessment(
                "assessment-bad",
                "this assessment should fail",
                requestedApplicability,
                []gemara.AssessmentStep{
                        step_Pass,
                        step_Fail,
                },
        )
        return
}</span>

func needsReviewEvaluation() (evaluation *gemara.ControlEvaluation) <span class="cov2" title="2">{
        evaluation = &amp;gemara.ControlEvaluation{
                Control: gemara.Mapping{
                        EntryId: "needs-review-evaluation",
                },
        }

        evaluation.AddAssessment(
                "assessment-review",
                "this assessment should need review",
                requestedApplicability,
                []gemara.AssessmentStep{
                        step_NeedsReview,
                },
        )
        return
}</span>

var requestedApplicability = []string{"tlp-green", "tlp-amber"}
var requestedCatalogs = []string{"catalog1", "catalog2", "catalog3"}

func setBasicConfig() *config.Config <span class="cov5" title="14">{
        viper.Set("service", "test-service")
        viper.Set("policy.applicability", requestedApplicability)
        viper.Set("policy.catalogs", requestedCatalogs)
        c := config.NewConfig(nil)
        return &amp;c
}</span>

func step_Pass(data interface{}) (result gemara.Result, message string, confidence gemara.ConfidenceLevel) <span class="cov8" title="71">{
        return gemara.Passed, "This step always passes"
}</span>

func step_Fail(_ interface{}) (result gemara.Result, message string, confidence gemara.ConfidenceLevel) <span class="cov1" title="1">{
        return gemara.Failed, "This step always fails"
}</span>

func step_NeedsReview(_ interface{}) (result gemara.Result, message string, confidence gemara.ConfidenceLevel) <span class="cov7" title="36">{
        return gemara.NeedsReview, "This step always needs review"
}</span>

// Helper function to create simple passing steps map
func createPassingStepsMap() map[string][]gemara.AssessmentStep <span class="cov4" title="8">{
        return map[string][]gemara.AssessmentStep{
                "CCC.Core.C01.TR01": {step_Pass},
        }
}</span>

// Helper function to get all requirement IDs from the test catalog
func getAllRequirementIds() ([]string, error) <span class="cov3" title="3">{
        catalog, err := getTestCatalog()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="3">var requirementIds []string
        for _, family := range catalog.Families </span><span class="cov5" title="9">{
                for _, control := range family.Controls </span><span class="cov7" title="39">{
                        for _, requirement := range control.AssessmentRequirements </span><span class="cov10" title="123">{
                                requirementIds = append(requirementIds, requirement.Id)
                        }</span>
                }
        }
        <span class="cov3" title="3">return requirementIds, nil</span>
}

// Helper function to convert evaluations to steps map for testing
// This is a simplified conversion for backward compatibility with existing tests
func convertEvalsToStepsMap(evals []*gemara.ControlEvaluation) map[string][]gemara.AssessmentStep <span class="cov4" title="5">{
        stepsMap := make(map[string][]gemara.AssessmentStep)

        // Handle empty evaluations
        if len(evals) == 0 </span><span class="cov2" title="2">{
                // Return empty map for empty evaluations
                return stepsMap
        }</span>

        // Get all requirement IDs from the actual test catalog
        <span class="cov3" title="3">requirementIds, err := getAllRequirementIds()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to a basic set if catalog loading fails
                requirementIds = []string{"CCC.Core.C01.TR01"}
        }</span>

        // If no requirement IDs found, return empty map
        <span class="cov3" title="3">if len(requirementIds) == 0 </span><span class="cov0" title="0">{
                return stepsMap
        }</span>

        // Determine the steps to use based on the evaluation type
        <span class="cov3" title="3">var primarySteps []gemara.AssessmentStep
        if len(evals) &gt; 0 </span><span class="cov3" title="3">{
                switch evals[0].Control.EntryId </span>{
                case "good-evaluation":<span class="cov2" title="2">
                        primarySteps = []gemara.AssessmentStep{step_Pass}</span>
                case "bad-evaluation":<span class="cov0" title="0">
                        primarySteps = []gemara.AssessmentStep{step_Pass, step_Fail}</span>
                case "needs-review-evaluation":<span class="cov1" title="1">
                        primarySteps = []gemara.AssessmentStep{step_NeedsReview}</span>
                default:<span class="cov0" title="0">
                        primarySteps = []gemara.AssessmentStep{step_Pass}</span>
                }
        } else<span class="cov0" title="0"> {
                primarySteps = []gemara.AssessmentStep{step_Pass}
        }</span>

        // Apply the pattern based on the number of evaluations
        <span class="cov3" title="3">for i, requirementId := range requirementIds </span><span class="cov10" title="123">{
                if len(evals) &gt; 1 &amp;&amp; i &lt; len(evals) </span><span class="cov2" title="2">{
                        // For multiple evaluations, use each evaluation's specific pattern
                        eval := evals[i]
                        switch eval.Control.EntryId </span>{
                        case "good-evaluation":<span class="cov1" title="1">
                                stepsMap[requirementId] = []gemara.AssessmentStep{step_Pass}</span>
                        case "bad-evaluation":<span class="cov1" title="1">
                                stepsMap[requirementId] = []gemara.AssessmentStep{step_Pass, step_Fail}</span>
                        case "needs-review-evaluation":<span class="cov0" title="0">
                                stepsMap[requirementId] = []gemara.AssessmentStep{step_NeedsReview}</span>
                        default:<span class="cov0" title="0">
                                stepsMap[requirementId] = []gemara.AssessmentStep{step_Pass}</span>
                        }
                } else<span class="cov9" title="121"> {
                        // For single evaluation or remaining requirements, use the primary pattern
                        stepsMap[requirementId] = primarySteps
                }</span>
        }

        <span class="cov3" title="3">return stepsMap</span>
}

// Test data for the main TestEvaluate function
func getTestEvaluateData() []testingData <span class="cov1" title="1">{
        return []testingData{
                {
                        testName:       "Good Evaluation",
                        expectedResult: gemara.Passed,
                        evals: []*gemara.ControlEvaluation{
                                passingEvaluation(),
                        },
                        steps: convertEvalsToStepsMap([]*gemara.ControlEvaluation{
                                passingEvaluation(),
                        }),
                },
                {
                        testName:       "Empty Steps Map",
                        expectedResult: gemara.NotRun,
                        evals: []*gemara.ControlEvaluation{
                                passingEvaluation(),
                        },
                        steps:                  map[string][]gemara.AssessmentStep{},
                        expectedEvalSuiteError: NO_ASSESSMENT_STEPS_PROVIDED("sel10"),
                },
                {
                        testName:       "Nil Steps Map",
                        expectedResult: gemara.NotRun,
                        evals: []*gemara.ControlEvaluation{
                                passingEvaluation(),
                        },
                        steps:                  nil,
                        expectedEvalSuiteError: NO_ASSESSMENT_STEPS_PROVIDED("sel10"),
                },
                {
                        testName:       "Mixed Evaluation Results",
                        expectedResult: gemara.Failed,
                        evals: []*gemara.ControlEvaluation{
                                passingEvaluation(),
                                failingEvaluation(),
                        },
                        steps: convertEvalsToStepsMap([]*gemara.ControlEvaluation{
                                passingEvaluation(),
                                failingEvaluation(),
                        }),
                },
                {
                        testName:       "Needs Review Evaluation",
                        expectedResult: gemara.NeedsReview,
                        evals: []*gemara.ControlEvaluation{
                                needsReviewEvaluation(),
                        },
                        steps: convertEvalsToStepsMap([]*gemara.ControlEvaluation{
                                needsReviewEvaluation(),
                        }),
                },
                {
                        testName:       "Empty Evaluations List",
                        expectedResult: gemara.NotRun,
                        evals:          []*gemara.ControlEvaluation{},
                        steps:          convertEvalsToStepsMap([]*gemara.ControlEvaluation{}),
                },
                {
                        testName:       "Nil Evaluations List",
                        expectedResult: gemara.NotRun,
                        evals:          nil,
                        steps:          convertEvalsToStepsMap(nil),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package utils

import (
        "math/rand"
        "time"
        "unsafe"
)

const (
        letters         = "abcdefghijklmnopqrstuvwxyz"
        letterIndexBits = 6                      // 6 bits to represent a letter index
        letterIdxMask   = 1&lt;&lt;letterIndexBits - 1 // All 1-bits, as many as letterIndexBits
        letterIdxMax    = 63 / letterIndexBits   // # of letter indices fitting in 63 bits
)

// src is a global variable that generates a new seed for the random number generator
var src = rand.NewSource(time.Now().UnixNano())

// RandomString generates a pseudo-random number of characters of length n
func RandomString(n int) string <span class="cov0" title="0">{
        bytes := make([]byte, n)
        // A src.Int63() generates 63 random bits, enough for letterIdxMax characters!
        for i, cache, remain := n-1, src.Int63(), letterIdxMax; i &gt;= 0; </span><span class="cov0" title="0">{
                if remain == 0 </span><span class="cov0" title="0">{
                        cache, remain = src.Int63(), letterIdxMax
                }</span>
                <span class="cov0" title="0">if idx := int(cache &amp; letterIdxMask); idx &lt; len(letters) </span><span class="cov0" title="0">{
                        bytes[i] = letters[idx]
                        i--
                }</span>
                <span class="cov0" title="0">cache &gt;&gt;= letterIndexBits
                remain--</span>
        }

        <span class="cov0" title="0">return *(*string)(unsafe.Pointer(&amp;bytes))</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package utils provides general utility methods.  The '*Ptr' functions were borrowed/inspired by the kubernetes go-client.
package utils

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strings"
)

func init() {<span class="cov1" title="1">
}</span>

// BoolPtr returns a pointer to a bool
func BoolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

// StringPtr returns a pointer to the passed string.
func StringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

// Int64Ptr returns a pointer to an int64
func Int64Ptr(i int64) *int64 <span class="cov0" title="0">{
        return &amp;i
}</span>

// JSON marshals a struct into JSON with indentation
func JSON(data interface{}) []byte <span class="cov0" title="0">{
        j, _ := json.MarshalIndent(data, "", "  ")
        return []byte(j)
}</span>

// FindString searches a []string for a specific value.
// If found, returns the index of first occurrence, and True. If not found, returns -1 and False.
func FindString(slice []string, val string) (int, bool) <span class="cov5" title="3">{
        for i, item := range slice </span><span class="cov10" title="10">{
                if item == val </span><span class="cov3" title="2">{
                        return i, true
                }</span>
        }
        <span class="cov1" title="1">return -1, false</span>
}

// CallerName retrieves the name of the function prior to the location it is called
// If using CallerName(0), the current function's name will be returned
// If using CallerName(1), the current function's parent name will be returned
// If using CallerName(2), the current function's parent's parent name will be returned
func CallerName(up int) string <span class="cov5" title="3">{
        s := strings.Split(CallerPath(up+1), ".") // split full caller path
        return s[len(s)-1]                        // select last element from caller path
}</span>

// CallerPath checks the goroutine's stack of function invocation and returns the following:
// For up=0, return full caller path for caller function
// For up=1, returns full caller path for caller of caller
func CallerPath(up int) string <span class="cov7" title="5">{
        f := make([]uintptr, 1)
        runtime.Callers(up+2, f)                  // add full caller path to empty object
        return runtime.FuncForPC(f[0] - 1).Name() // get full caller path in string form
}</span>

// CallerFileLine returns file name and line of invoker
// Similar to CallerName(1), but with file and line returned
func CallerFileLine() (string, int) <span class="cov0" title="0">{
        _, file, line, _ := runtime.Caller(2)
        return file, line
}</span>

// ReformatError prefixes the error string ready for logging and/or output
func ReformatError(e string, v ...interface{}) error <span class="cov1" title="1">{
        var b strings.Builder
        b.WriteString("[ERROR] ")
        b.WriteString(e)

        return fmt.Errorf(b.String(), v...)
}</span>

// ReplaceBytesValue replaces a substring with a new value for a given string in bytes
func ReplaceBytesValue(b []byte, old string, new string) []byte <span class="cov8" title="7">{
        newString := strings.ReplaceAll(string(b), old, new)
        return []byte(newString)
}</span>

// ReplaceBytesMultipleValues replaces multiple substring with a new value for a given string in bytes
func ReplaceBytesMultipleValues(b []byte, replacer *strings.Replacer) []byte <span class="cov0" title="0">{
        newString := replacer.Replace(string(b))
        return []byte(newString)
}</span>

// WriteAllowed determines whether a given filepath can be written to
func WriteAllowed(path string) error <span class="cov0" title="0">{
        _, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY, 0644)
        if os.IsPermission(err) </span><span class="cov0" title="0">{
                return ReformatError("Permissions prevent this from writing to file: ", path)
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return ReformatError(fmt.Sprintf(
                        "Could not create or write to file: %s. Error: %s", path, err))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetExecutableName returns name of executable without file extension
func GetExecutableName() string <span class="cov1" title="1">{
        execAbsPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[ERROR] Critical error occurred while getting executable name")
        }</span>

        <span class="cov1" title="1">execName := filepath.Base(execAbsPath)

        // Remove extension if it exists
        if ext := filepath.Ext(execName); ext != "" </span><span class="cov1" title="1">{
                execName = strings.TrimSuffix(execName, ext)
        }</span>

        <span class="cov1" title="1">return execName</span>
}

func StringSliceContains(arr []string, val string) bool <span class="cov0" title="0">{
        for _, a := range arr </span><span class="cov0" title="0">{
                if a == val </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
